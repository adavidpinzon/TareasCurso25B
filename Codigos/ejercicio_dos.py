# -*- coding: utf-8 -*-
"""ejercicio dos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Tx4Ywsto18j6UXrAR1Y4BZwde-qMqUQ
"""

#ortogonalización de Gram-Schmidt para dos productos internos diferentes y comparar aproximaciones.
import sympy as sp
from sympy import Matrix, integrate, symbols, sin, plot, simplify
import numpy as np
import matplotlib.pyplot as plt

def crear_base_monomios(grado_max, variable):
    """Crea base de monomios hasta el grado especificado"""
    return [Matrix([variable**n]) for n in range(grado_max + 1)]

def verificar_ortogonalidad(base, producto_interno):
    """Verifica si una base es ortogonal bajo el producto interno dado"""
    ortogonal = True
    n = len(base)

    for i in range(n):
        for j in range(i + 1, n):
            resultado = producto_interno(base[i], base[j])
            print(f"Producto interno entre P{i} y P{j}: {simplify(resultado)}")
            if resultado != 0:
                ortogonal = False

    return ortogonal

def gram_schmidt(base, producto_interno):
    """Aplica el proceso de Gram-Schmidt a una base"""
    ortogonales = []

    for v in base:
        u = v.copy()
        for o in ortogonales:
            proyeccion = (producto_interno(v, o) / producto_interno(o, o)) * o
            u -= proyeccion
        ortogonales.append(u)

    return ortogonales

def calcular_coeficientes(funcion, base, producto_interno):
    """Calcula coeficientes para aproximar una función en una base ortogonal"""
    coeficientes = []
    for vi in base:
        numerador = producto_interno(funcion, vi)
        denominador = producto_interno(vi, vi)
        coeficientes.append(numerador / denominador)
    return coeficientes

def construir_aproximacion(coeficientes, base):
    """Construye la aproximación lineal a partir de coeficientes y base"""
    return sum(coef[0] * base_func[0] for coef, base_func in zip(coeficientes, base))

def graficar_comparacion(funciones, etiquetas, colores, titulo, variable, rango=(-1, 1)):
    """Grafica múltiples funciones para comparación"""
    p = plot(show=False)

    for i, (func, label, color) in enumerate(zip(funciones, etiquetas, colores)):
        p_i = plot(func, (variable, rango[0], rango[1]), show=False)[0]
        p_i.line_color = color
        p_i.label = label
        p.append(p_i)

    p.title = titulo
    p.xlabel = str(variable)
    p.ylabel = 'f(t)'
    p.legend = True
    p.legend_loc = 'upper left'
    p.show()

def main():
    # Configuración inicial
    t = symbols('t')
    a, b = -1, 1
    grado_max = 9

    # Definir productos internos
    def producto1(f, g):
        return integrate(f[0] * g[0], (t, a, b))

    def producto2(f, g):
        return integrate(f[0] * g[0] * sp.sqrt(1 - t**2), (t, a, b))

    # Crear base de monomios
    base = crear_base_monomios(grado_max, t)

    # Verificar ortogonalidad de la base original
    print("=== VERIFICACIÓN DE ORTOGONALIDAD ===")
    ortogonal1 = verificar_ortogonalidad(base, producto1)
    print(f"a) El conjunto {'es' if ortogonal1 else 'no es'} ortogonal bajo el producto 1\n")

    # Ortogonalizar bases
    print("=== ORTOGONALIZACIÓN ===")
    ortogonales1 = gram_schmidt(base, producto1)  # Polinomios de Legendre
    ortogonales2 = gram_schmidt(base, producto2)  # Polinomios de Chebyshev

    # Mostrar polinomios ortogonales simplificados
    print("b) Polinomios de Legendre (simplificados):")
    for i, p in enumerate(ortogonales1):
        pol_simplificado = simplify(p[0])
        print(f"  P_{i}(t) = {pol_simplificado}")

    print("\nc) Polinomios de Chebyshev (simplificados):")
    for i, p in enumerate(ortogonales2):
        pol_simplificado = simplify(p[0])
        print(f"  T_{i}(t) = {pol_simplificado}")

    # Función a aproximar
    h = Matrix([sp.sin(3*t) * (1 - t**2)])

    # Calcular aproximaciones
    print("\n=== APROXIMACIONES ===")

    # Aproximación en base monomios
    coef_monomios = calcular_coeficientes(h, base, producto1)
    aprox_monomios = construir_aproximacion(coef_monomios, base)

    # Aproximación en base Legendre
    coef_legendre = calcular_coeficientes(h, ortogonales1, producto1)
    aprox_legendre = construir_aproximacion(coef_legendre, ortogonales1)

    # Aproximación en base Chebyshev
    coef_chebyshev = calcular_coeficientes(h, ortogonales2, producto1)
    aprox_chebyshev = construir_aproximacion(coef_chebyshev, ortogonales2)

    # Simplificar aproximaciones para mejor visualización
    aprox_monomios_simpl = simplify(aprox_monomios)
    aprox_legendre_simpl = simplify(aprox_legendre)
    aprox_chebyshev_simpl = simplify(aprox_chebyshev)

    print(f"Aproximación monomios: {aprox_monomios_simpl}")
    print(f"Aproximación Legendre: {aprox_legendre_simpl}")
    print(f"Aproximación Chebyshev: {aprox_chebyshev_simpl}")

    # Graficar comparaciones
    funciones_legendre = [aprox_monomios_simpl, aprox_legendre_simpl, h[0]]
    etiquetas_legendre = ['Aproximación monomios', 'Aproximación Legendre', 'Función original']
    colores_legendre = ['red', 'blue', 'green']

    funciones_chebyshev = [aprox_monomios_simpl, aprox_chebyshev_simpl, h[0]]
    etiquetas_chebyshev = ['Aproximación monomios', 'Aproximación Chebyshev', 'Función original']
    colores_chebyshev = ['red', 'blue', 'green']

    graficar_comparacion(funciones_legendre, etiquetas_legendre, colores_legendre,
                        'Comparación: Monomios vs Legendre', t)

    graficar_comparacion(funciones_chebyshev, etiquetas_chebyshev, colores_chebyshev,
                        'Comparación: Monomios vs Chebyshev', t)

if __name__ == "__main__":
    main()